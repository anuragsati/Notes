

sum(a, b)  =  xor(a, b)  +  2 * and(a, b)



------total no. of prime factors of a number = multiply power of each prime factor +1 of that number

********To find prime factors in sqrt(N) time naive implimentation
****************faster log(n) here ===>https://www.geeksforgeeks.org/prime-factorization-using-sieve-olog-n-multiple-queries/

        void primeFactors(int n) 
        { 
            // Print the number of 2s that divide n 
                while (n%2 == 0) 
                { 
                    printf("%d ", 2); 
                    n = n/2; 
                } 
        
            // n must be odd at this point.  So we can skip one element
            
                for (int i = 3; i <= sqrt(n); i = i+2) 
                { 
                    // While i divides n, print i and divide n 
                    while (n%i == 0) 
                    { 
                        printf("%d ", i); 
                        n = n/i; 
                    } 
                } 
        
            // This condition is to handle the case when n  
            // is a prime number greater than 2 
                if (n > 2) 
                    printf ("%d ", n); 
        }
        
*************to store values of prime factors and powers in a map

        void findpf(int n, map<int, int> &m){
            while(n%2 == 0){
                m[2]++;
                n/=2;
            }
            for(int i=3; i*i <= n; i+=2){
                while(n%i == 0){
                    m[i]++;
                    n /= i;
                }
            }
            if(n > 2)
                m[n]++;
        }
============================================================================================
********To check how many times we need to divide something

        ceil((float)a/b)-1
        
        always type cast a ******(always)

        -1 when a is completely divisible by b
        
============================================================================================
******To check whether a number is decimal or an integer : *****

    (long double)sqrt(a[i]) == floor(sqrt(a[i]))

    OR

    if(ceil(n) == floor(n))
        cout << "integer";
    else
        cout << "decimal";

    OR

    float x;
    int z = abs(x);

    if(x==z)        //abs will always be int so if no. has xxxx.0000 then it will be same as int
        cout << "integer";
    else
        cout << "float";

============================================================================================
**** To flip states of a number every time we loop through it : *****

    int p = 0;      // initial value

    while(1){
        p = 1-p;    //change
    }
    

    ************ OR ********
    int x = 0;
    (x == 0) ? +1 : -1;
    
===========================================================================================
***** count leading and trailing zeroes using builtin gcc functions******

    __builtin_clz(x);   //count leading zeroes
    __builtin_ctz(x);   //count trailing zeroes
    
===========================================================================================
**** to check power of 2 or not ******
    logic : if x is isPowerOfTwo then it has only one 1 in its binary form
            and x-1 will have all 1's right of the zero
            so (x & x-1) will be zero if x isPowerOfTwo
            
    bool isPowerOfTwo(int x) 
    { 
        // First x in the below expression is 
        // for  the case when x is 0  
        
        return x && (!(x & (x - 1))); 
    } 
    
===========================================================================================
***** convert binary to integer *****

    auto n = 100010101;
    cout << n;

===========================================================================================
Brian Kernighan’s Algorithm:

    Subtracting 1 from a decimal number flips all the bits after
    the rightmost set bit(which is 1) including the rightmost set bit.
    for example :
    
    10 in binary is 00001010
    9 in binary is 00001001
    8 in binary is 00001000
    7 in binary is 00000111
    
    So if we subtract a number by 1 and do bitwise & with itself (n & (n-1)), 
    we unset the rightmost set bit. If we do n & (n-1) in a loop and count 
    the no of times loop executes we get the set bit count.


        /* Function to get no of set bits in binary 
    representation of passed binary no. */
    
    unsigned int countSetBits(int n){
        unsigned int count = 0; 
        while (n) { 
            n &= (n - 1); 
            count++; 
        } 
        return count; 
    } 

============================================================================================

(x&-x) == (~x)+1        //two's compliment

x += (x&-x)         //going to child in fenwick tree
x -= (x&-x)         //going to parent in fenwick tree


============================================================================================
for distinct selections 

    vi dp(k+1, 0);
    dp[0] = 1;
    for(auto c:a){              //for every coin 
        for(int i=c; i<=k; i++){
            dp[i] += dp[i-c];
        }
    }

for same selections refer to cp.pdf

============================================================================================
********************DSU**************
    replace all the occurance 
    connected components

    to find combined height of dsu tree

    int ans = 0;                //sz is size array and id is dsu array
    for (int i = 0; i < n; ++i) 
        if (id[i] == i) 
            ans += (sz[i] - 1); 
            